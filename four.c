//隐式类型转换 存储过程中会发生截断
//整型提升就是指在计算过程中一些操作数达不到整形（int四个字节）大小的时候会发生的，将他变为一个整型再进行计算
//整型提升是指为了获得这个精度，表达式的字符和短整型操作数在使用之前被转换成普通整形，这种转换称之为整型提升
//整型提升的规则：整型提升是按照变量的数据类型的符号位来提升的
/*#include<stdio.h>
int main()
{
	char a=3;
	//00000000000000000000000000000011 原本3的二进制
	//00000011 由于给3的是char类型，只占一个字节，8个比特位，所以从后往前截取8位
	char b=127;
	//00000000000000000000000001111111 127的二进制
	//01111111同理从后往前截取8个比特位
	//为获得这个精度，表达式中的字符的短整型操作数在使用之前被转换为普通整数，这种转换称之为整形提升
	//整型提升是按照变量的数据类型的符号位来提升的
	//负数的话符号位是1，所以高位补全1，正数的话符号位是0，所以高位补全0；无符号数在高位直接补全0
	char c=a+b;
    //char是有符号数，如果是无符号数直接前面补0就可以了
	//3：00000011（最前面的0相当于是符号位，保留最前面的符号位，前面补全0）变为00000000000000000000000000000011
	//127：01111111（同上同理）变为00000000000000000000000001111111
	//相加之后变为0000000000000000000000000010000010
	//由于保存在c中的c也是char类型，所以从后往前保留8位 就是10000010
	//打印整形 所以要给C进行整型提升 由于c的高位符号位是1，所以在前面补全1变为11111111111111111110000010（这个是补码）
	//11111111111111111110000010（这个是补码）,真正需要打印出来的是原码
	//11111111111111111110000001(这个是反码)，补码减去1得到的
	//10000000000000000001111110(这个是原码)，反码的符号位不变，其余取反之后得到的
	//10000000000000000001111110是-126
	printf("%d\n,c"); //-126
	return 0;
}*/
//整型提升的案例
/*#include<stdio.h>
int main()
{
	char d=0x80;//128 10000000  1111111111111111111111110000000 1111111111111111111111101111111 10000000000000000000001000000
	char a=0xb6;//182十六进制转换为二进制，只需要将十六进制的每一个转换为对应的二进制数并拼接起来
	//b6中b代表11，二进制为1011，后面的6转化为二进制数为0110，所以b6的二进制数为10110110
	//10110110由于符号位是1所以高位补全1 为11111111111111111110110110(补码) 十进制为4,294,967,222
	//11111111111111111110110101 反码（补码减一）
	//10000000000000000001001010 原码（除了符号位其余按位取反）
	short b=0xb600;//同上同理
	int c=0xb6000000;//因为c本来就是整形（int）所以不要整型提升
//#if 0
	if(d==-128)
		printf("d\n");
	if(a==0xb6)
		printf("a\n");
	if(b==0xb600)
		printf("b\n");
	if(c==0xb6000000)
		printf("c\n"); 
//#endif
	//printf("%d\n",a);//-74
	//printf("%d",d);//-128
	return 0;
}*/
/*#include<stdio.h>
int main()
{
	char a=0x81;//0x81十进制是129，二进制为00000000000000010000001；由于是char类型所以发生截断，变为10000001
	//由于截断之后变为10000001，符号位是1；所以补全1 变为1111111111111110000001
	//1111111111111110000001 补码
	//1111111111111110000000 反码
	//1000000000000001111111 原码
	if(a==0x81)
		printf("a\n");
	printf("%d\n",a);//-127
	return 0;
}*/
/*#include<stdio.h>
int main()
{	char a=0x40;//十进制为64 二进制为00000000000000000001000000 截断为01000000 
   //截断之后的为01000000 符号位是0，补全0为000000000000000000001000000 由于符号位是0，所以是正数，补码原码反码都相等 
	char b=0x80;//十进制为128 二进制位00000000000000000010000000 截断为10000000
	//阶段之的后为10000000 符号位是1，补全1为111111111111111111110000000 由于符号位是1，所以是负数，得通过补码求原码
	//111111111111111111110000000 补码
	//111111111111111111101111111 反码
	//100000000000000000010000000 原码  -128
	if(a==0x40)
		printf("a\n");
	if(b==0x80)
		printf("b\n");
	printf("a=%d b=%d",a,b);
	return 0;
}*/
//小知识点，int在32位机器和64位机器都占4个字节；指针在32位占4个字节，在64位占8个字节
//操作系统可以使用的最大内存空间在32位机器为2**32；在64位的机器为2**64
//整形提升的案例2
/*#include<stdio.h>
int main()
{
//%d 有符号10进制整数 
//%i 有符号10进制整数 
//%o 无符号8进制整数 
//%u 无符号10进制整数 
//%x 无符号的16进制数字，并以小写abcdef表示
//%X 无符号的16进制数字，并以大写ABCDEF表示
//%F/f 浮点数 
//%E/e 用科学表示格式的浮点数 
//%g 使用%f和%e表示中的总的位数表示最短的来表示浮点数 G 同g格式，但表示为指数 
//%c 单个字符 
//%s 字符串
	char c=1;
	printf("%u\n",sizeof(c));//1
	printf("%u\n",sizeof(+c));//4
	//+c就需要进行计算，计算就需要进行整型提升 所以就变为整形 sizeof就是4
	printf("%u\n",sizeof(!c));//1
	return 0;
}*/
//算术转换
/*#include<stdio.h>
int main()
{
	//long double
	//double
	//float
	//unsigned long int
	//long int
	//unsigned int
	//int
	//如果两个不同类型的数字之间需要进行运算，就需要将下面的转换成上面的再进行运算
	//比如一个unsigned int 和一个int类型的需要进行运算，就需要先将int(在上面的表格相对于unsigned int处于下面)转换成unsigned int(相对于int处于上面)
	return 0;
}*/