//交换两个变量，不使用第三个值
//方法一：算术运算（有缺陷，可能会溢出）
/*#include<stdio.h>
int main()
{
	int a=5;
	int b=3;
	a=a+b;//a=8
	b=a-b;//b=5
	a=a-b;//a=3
	printf("a=%d b=%d",a,b);
	return 0;
}*/
/*把a、b看做数轴上的点，围绕两点间的距离来进行计算。
具体过程：第一句“a=b-a”求出ab两点的距离，并且将其保存在a中；第二句“b=b-a”求出a到原点的距离（b到原点的距离与ab两点距离之差），并且将其保存在b中；
第三句“a=b+a”求出b到原点的距离（a到原点距离与ab两点距离之和），并且将其保存在a中。完成交换。此算法与标准算法相比，多了三个计算的过程，但是没有借助临时变量。（以下称为算术算法）
缺点：是只能用于数字类型，字符串之类的就不可以了。a+b有可能溢出(超出int的范围)，溢出是相对的， +了溢出了，-回来不就好了，所以溢出不溢出没关系，就是不安全。
*/


//方法二：通过按位异或的解决问题
//规则是：两个操作数，转为二进制，相同则为0，不同则为1
/*#include<stdio.h>
int main()
{	
	int a=5;//5的二进制为00000000000000000000000000000101
	int b=3;//3的二进制为00000000000000000000000000000011
	a=a^b;//此时a二进制为00000000000000000000000000000110
	b=a^b;//此时b二进制为00000000000000000000000000000101
	a=a^b;//此时a二进制为00000000000000000000000000000011
	printf("a=%d b=%d",a,b);
	return 0;
}*/
//此算法能够实现是由异或运算的特点决定的，通过异或运算能够使数据中的某些位翻转，其他位不变。这就意味着任意一个数与任意一个给定的值连续异或两次，值不变