//数据的存储
//整形在内存中的存储
/*原码、反码、补码
计算机中的有符号数（整形（正数的原码反码补码是相同的））有三种表示方法，即原码、反码和补码。（无符号数：原码、反码、补码是相同的）
三种表示方法均有符号位和数值位两部分，符号位都是用0表示"正”，用1表示""负”，而数值位三种表示方法各不相同。
原码
直接将二进制按照正负数的形式翻译成二进制就可以。
反码
将原码的符号位不变，其他位依次按位取反就可以得到了。
补码
反码+1就得到补码
对于整形来说：数据存放内存中其实存放的是补码
原因：在计算机系统中，数值一律用补码来表示和存储。原因在于，使用补码，可以将符号位和数值域统一处理;同时，加法和减法也可以统一处理( CPU只有加法器）此外，补码与原码相互转换，其运算过程是相同的，不需要额外的硬件电路。
举例：
1-1写成1+(-1)
0000000000000000000000000000001 1的补码
1111111111111111111111111111111 -1的补码
10000000000000000000000000000000 1和-1的补码相加的结果，因为是32位，所以从后往前截取32位，为0000000000000000000000000000000 也就是0
内存的存储分为大端(存储)模式和小端(存储)模式
大端(储存)模式也叫大端字节序存储模式.是指数据的低位保存在内存的高地址中，而数据的高位，保存在内存的低地址中
小端(存储)模式也叫小端字节序存储模式，是指数据的低位保存在内存的低地址中，而数据的高位，保存在内存的高地址中
如 0x 11 22 33 44;11端为高地址端，44端为低地址端   内存中左端为低地址，右端为高地址
如果按照11 22 33 44存储就是大端(存储)模式  按照44 33 22 11存储就是小端(存储)模式
#include<stdio.h>
int main()
{
	int a=20;//20个字节--32个比特位
	//00000000000000000000000000010100  原码
	//00000000000000000000000000010100  反码
	//00000000000000000000000000010100  补码
	//0x00000014 十六进制
	int b=-10;
	//10000000000000000000000000001010  原码
	//11111111111111111111111111110101  反码
	//11111111111111111111111111110110  补码
	//FFFFFFF6 十六进制
	return 0;
}*/
//设计一个小程序来判断当前机器的字节序
/*#include<stdio.h>
int check_sys()
{
	int a=1;//0x 00 00 00 01
//	char* p=(char*)&a;
	//指针类型的意义:
//1，指针类型决定了指针解引用操作符能访问几个字节: char*p;*p访问了1个字节，int*p; *p访问4个字节
//2，指针类型决定了指针+1，-1，加的或者减的是几个字节;char*p;p+1,跳过一个字符，int*p;p+1,跳过一个整形-4个字节
//#if 0(方法一)
//	if(*p==1)
//	{
//		return 1;
//	}
//	else
//	{
//		return 0;
//	}
//#endif
//	//返回1，那就是小端
//	//返回0，就是大端
//	return *p;（方法二）
	//或者直接写成
	return *(char *)&a;//（方法三）
}
int main()
{
	int ret=check_sys();
	//返回1，那就是小端
	//返回0，就是大端
	if(ret==1)
	{
		printf("小端\n");
	}
	else
		printf("大端\n");
	return 0;
}
//输出什么？
#include <stdio.h>
int main()
{
	char a=-1;
	//原码 1000000000000000000000000000001
	//反码 1111111111111111111111111111110
	//补码 1111111111111111111111111111111
	//11111111 
	//因为打印的是%d,是整形，所以会发生整型提升 因为是char类型，是有符号数，所以最前面的是1，所以补全1
	//补全后为11111111111111111111111111111111（-1的补码） 所以还是-1(补码)
	//        11111111111111111111111111111110 （-1的反码）
	//        10000000000000000000000000000001 （-1的原码）所以是-1
	signed char b=-1;
	//11111111
	//b和a是一样的，因为是有符号数所以和a是一样的，打印出来是-1
	unsigned char c=-1;
	//11111111
	//因为c是无符号数，所以最高位的1不是符号位，所以补全0
	//补全为00000000000000000000000011111111 因为无符号数的原码反码补码都相同，所以直接打印出来为255
	printf("a=%d,b=%d,c=%d",a,b,c);//-1，-1，255
	return 0;
}*/
/*#include<stdio.h>
int main()
{
	char a=-128;
	char a1=128;
	char b=-1;
	char b1=255;
	char c=-127;
	char c1=129;
	//10000000000000000000000010000000 -128的二进制也就是原码
	//11111111111111111111111101111111 -128的反码
	//11111111111111111111111110000000 -128的补码
	//10000000 a发生截断,因为是char类型
	//11111111111111111111111110000000 发生整形提升，因为是char是有符号数，高位是1，所以补全1
	//因为是%u所以认为是无符号数，所以原码反码补码都是11111111111111111111111110000000 所以是4294967168
	printf("%u\n",a);//4294967168
	printf("%u\n",a1);//4294967168
	printf("%u\n",b);//4294967295
	printf("%u\n",b1);//4294967295
	printf("%u\n",c);//4294967169
	printf("%u\n",c1);//4294967169
	//%d -打印十进制的有符号数字于 
	//%u-打印十进制的无符号数字
	return 0;
}*/
//有符号的char的范围是-128--->127   10000000是-128
//无符号的char的范围是0------>255
//求下面的值
/*#include<stdio.h>
int main()
{
	int i=-20;
	//10000000000000000000000000010100 -20的原码
	//11111111111111111111111111101011 -20的反码
	//11111111111111111111111111101100 -20的补码
	unsigned int j=10;
	//00000000000000000000000000001010 10的原码反码补码
	//11111111111111111111111111110110 10和-20的补码相加得到的结果（补码）
	//11111111111111111111111111110101 10和-20的补码相加得到的结果（反码）
	//10000000000000000000000000001010 10和-20的补码相加得到的结果（原码）是-10
	printf("%d\n",i+j);//-10
	return 0;
}*/
/*#include<stdio.h>
#include<Windows.h>
int main()
{
	unsigned int i;
	for(i=9;i>=0;i--)
	{
		//printf("%u\n",i);//%u-打印十进制的无符号数字//死循环，因为i是无符号数，他一直是大于等于0 的，所以for循环的条件一直成立,无论最后打印的是%d,还是%u
		//9 8 7 6 5 4 3 2 1 0 4294967295 4294967294 4294967293 4294967292......
		printf("%d\n",i);
		//9 8 7 6 5 4 3 2 1 -1 -2 -3 -4 -5 -6......
		Sleep(100);//执行一次睡眠0.1秒
	}  
	return 0;
}*/
/*#include<stdio.h>
#include<string.h>
int main()
{
	char a[1000];
	int i;
	for(i=0;i<1000;i++)
	{
		a[i]=-1-i;//你可能认为是-1 -2 -3 .....-1000,因为没有'\0',所以输出一个随机数
		printf("%d\t",a[i]);
	}            //但是这道题a是char类型，它的范围是-128--->127，所以从-1 -2 -3...-128，他不能到-129，所以他会把-128--->127范围外的数据，转换成范围内的数据
	            //-1 -2 -3....-127 -128 127 126 125....3 2 1 0 -1 -2 -3 .....
	printf("%d",strlen(a));//255 strlen计算字符串长度的时候，遇到'\0'就停止，所以当循环到0的时候停止。strlen=127+128=255
	return 0;
}*/
/*#include<stdio.h>
unsigned char i=0;//unsigned char的范围是0---255  255+1变成0 在for循环里恒成立
int main()
{
	for(i=0;i<=255;i++)
	{
		printf("hello world\n");//死循环
	}
	return 0;
}*/
//浮点数在内存中的存储
/*#include<stdio.h>
//9.0
//小数点前的二进制，也就是9的二进制 1001，小数点后的是0,可以是2^0所以就是1001.0
//(-1)^0 * 1.001 * 2^3  如果是正数的话，就是(-1)*0,如果是负数的话，就是(-1)*1 再把1001.0变为科学计数法，就是1.001*2^3 因为是二进制，所以是2^3,如果是十进制就是10^3
//(-1)^S * M     * 2^E
//S--->0/1(正数是0，负数是1)
//M--->1.001
//E--->3
//E+127=130(double 类型的时候，加的是1023）
//
//0.5(十进制数)
//0.1（浮点数的二进制数）0代表2^0；1代表2^(-1),所以是0.5  
//(-1)^0  *  1.0 * 2^(-1)
//(-1)^S  *  M   * 2^E
//S=0
//M=1.0
//E=-1
//E+127=126
//对于32位的浮点数，最高位的1位是符号位S，接着8位是指数E，剩下的23位为有效数字M
//对于64位的浮点数，最高的1位是符号位S，接着的11位是指数E，剩下的52位为有效数字M
//IEEE 754对有效数字M和指数E，还有一些特别规定。前面说过，1<=M<2，也就是说，M可以写成1.xxxxxx的形式，其中xxxxxx表示小数部分。
//IEEE 754规定，在计算机内部保存M时，默认这个数的第一位总是1，因此可以被舍去，只保存后面的xxxxxx部分。比如保存1.01的时候，只保存01，等到读取的时候，再把第一位的1加上去。这样做的目的，是节省1位有效数字。以32位浮点数为例，留给M只有23位，将第一位的1舍去以后，等于可以保存24位有效数字。
//至于指数E，情况就比较复杂。
//首先，E为一个无符号整数(unsigned int ）这意味着，如果E为8位，它的取值范围为0~255;如果E为11位，它的取值范围为0~2047。但是，我们知道，科学计数法中的E是可以出现负数的，
//所以IEEE 754规定，存入内存时E的真实值必须再加上一个中间数，对于8位的E，这个中间数是127;对于11位的E，这个中间数是1023。比如，2^10的E是10，所以保存成32位浮点数时，必须保存成10+127=137，即10001001。
int main()
{
	int n=9;
	//0 00000000 000000000000000001001 补码
	//因为转换成了float，所以就认为第一位的0是S，后八个是E,剩下的是M（有效位）
	//因为E是全0，所以改成(-1)^0 * 0.00000000000000001001 * 2^-126(无限接近于0)
	float *pFloat=(float *)&n;//变量n为int型，&a就是int*类型，要把&a赋给char *p,就得强制类型转换，char *p=(char *)&a//int *,这样才不会报错
	printf("n的值为：%d\n",n);//9
	printf("pFloat的值为：%f\n",*pFloat);//0.000000

	*pFloat=9.0;
	//1001.0
	//(-1)^0 * 1.001 * 2^3
	//0 100000010 00100000000000000存到内存中的形式
	//n是个整数，所以按照整数的内存取 就是1091567616
	printf("num的值为：%d\n",n);//1091567616
	printf("pFloat的值为：%f\n",*pFloat);//9.000000
	return 0;
}*/
/*#include<stdio.h>
int main()
{
	float f=5.5;
	//5.5
	//101.1 整数部分5的二进制是101，小数部分是0.5，可以写成2^-1,也就是0.1（0.01代表2^-2,0.001代表2^-3）
	//1.011*2^2科学计数法
	//(-1)^0*1.001*2^2
	//S=0
	//M=1.011（前面的1不存，只存后面的小数位）
	//E=2 E=2+127=129 129的二进制序列是10000001
	//0 10000001 01100000000000000000000
	//0x40b00000 把上面的转换成十六进制
	//
	//3.14
	//11.001.......后面有好多0和1，精确到3.14
	return 0;
}*/
//然后，指数E从内存中取出还可以再分成三种情况∶
//E不全为0或不全为1
//这时，浮点数就采用下面的规则表示，即指数E的计算值减去127(或1023），得到真实值，再将有效数字M前加上第一位的1。比如∶0.5 ( 1/2)的二进制形式为0.1，由于规定正数部分必须为1，即将小数点右移1位，则为1.0*2^(-1)，其阶码为-1+127=126，表示为01111110，而尾数1.0去掉整数部分为0，补齐0到23位
//00000000000000000000000，则其二进制表示形式为:
//0 01111110 00000000000000000000000
//E全为0
//这时，浮点数的指数E等于1-127(或者1-1023 )即为真实值，有效数字M不再加上第一位的1，而是还原为0.xxxxxx的小数。这样做是为了表示+-0，以及接近于0的很小的数字。
//E全为1
//这时，如果有效数字M全为0，表示+-无穷大(正负取决于符号位s ) ;