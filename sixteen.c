//数据的存储
//整形在内存中的存储
/*原码、反码、补码
计算机中的有符号数（整形（正数的原码反码补码是相同的））有三种表示方法，即原码、反码和补码。（无符号数：原码、反码、补码是相同的）
三种表示方法均有符号位和数值位两部分，符号位都是用0表示"正”，用1表示""负”，而数值位三种表示方法各不相同。
原码
直接将二进制按照正负数的形式翻译成二进制就可以。
反码
将原码的符号位不变，其他位依次按位取反就可以得到了。
补码
反码+1就得到补码
对于整形来说：数据存放内存中其实存放的是补码
原因：在计算机系统中，数值一律用补码来表示和存储。原因在于，使用补码，可以将符号位和数值域统一处理;同时，加法和减法也可以统一处理( CPU只有加法器）此外，补码与原码相互转换，其运算过程是相同的，不需要额外的硬件电路。
举例：
1-1写成1+(-1)
0000000000000000000000000000001 1的补码
1111111111111111111111111111111 -1的补码
10000000000000000000000000000000 1和-1的补码相加的结果，因为是32位，所以从后往前截取32位，为0000000000000000000000000000000 也就是0
内存的存储分为大端(存储)模式和小端(存储)模式
大端(储存)模式也叫大端字节序存储模式.是指数据的低位保存在内存的高地址中，而数据的高位，保存在内存的低地址中
小端(存储)模式也叫小端字节序存储模式，是指数据的低位保存在内存的低地址中，而数据的高位，保存在内存的高地址中
如 0x 11 22 33 44;11端为高地址端，44端为低地址端   内存中左端为低地址，右端为高地址
如果按照11 22 33 44存储就是大端(存储)模式  按照44 33 22 11存储就是小端(存储)模式
#include<stdio.h>
int main()
{
	int a=20;//20个字节--32个比特位
	//00000000000000000000000000010100  原码
	//00000000000000000000000000010100  反码
	//00000000000000000000000000010100  补码
	//0x00000014 十六进制
	int b=-10;
	//10000000000000000000000000001010  原码
	//11111111111111111111111111110101  反码
	//11111111111111111111111111110110  补码
	//FFFFFFF6 十六进制
	return 0;
}*/
//设计一个小程序来判断当前机器的字节序
/*#include<stdio.h>
int check_sys()
{
	int a=1;//0x 00 00 00 01
//	char* p=(char*)&a;
	//指针类型的意义:
//1，指针类型决定了指针解引用操作符能访问几个字节: char*p;*p访问了1个字节，int*p; *p访问4个字节
//2，指针类型决定了指针+1，-1，加的或者减的是几个字节;char*p;p+1,跳过一个字符，int*p;p+1,跳过一个整形-4个字节
//#if 0(方法一)
//	if(*p==1)
//	{
//		return 1;
//	}
//	else
//	{
//		return 0;
//	}
//#endif
//	//返回1，那就是小端
//	//返回0，就是大端
//	return *p;（方法二）
	//或者直接写成
	return *(char *)&a;//（方法三）
}
int main()
{
	int ret=check_sys();
	//返回1，那就是小端
	//返回0，就是大端
	if(ret==1)
	{
		printf("小端\n");
	}
	else
		printf("大端\n");
	return 0;
}
