//分析错误代码（关于是循环的形成原因）
/*#include<stdio.h>
int main()
{
	int i=0;
	int arr[10]={1,2,3,4,5,6,7,8,9,10};
	for(i=0;i<=12;i++)//因为在arr[12]=0的时候，i从12变成了0，没有变成13跳出循环
	{                 //因为arr[12]和i是同一块空间 arr[12]=0，所以i也变成0
		printf("hehe\n");//死循环
		arr[i]=0;
	}
	return 0;
}*/
//内存是一块大的区域，分成三个小区域，一块叫栈区，一块叫堆区，一块叫静态区
//栈区里面存放局部变量，里面也存放着小区域,每个小区域都有地址，栈区的默认使用是先使用高地址处的空间，再使用低地址处的的空间
//数组存放的时候，数组随着下标的增长，地址是由低到高变化的
//当i的值大于等于12的时候，就会陷入死循环，但是并不是意味着不会报错，而是顾着一直死循环，所以顾不上报错
//如果i等于11的时候，就会报错，堆栈破损。


//sizeof操作符的练习
/*#include<stdio.h>
int main()
{
	int a=0;
	char b='w';
	int arr[10]={0};

	printf("%d\n",sizeof a);//4  变量可以省略括号，类型不可以
	printf("%d\n",sizeof(int));//4
	
	printf("%d\n",sizeof b);//1
	printf("%d\n",sizeof(char));//1

	printf("%d\n",sizeof(arr));//40  sizeof(arr)/sizeof(arr[0])=10
	printf("%d\n",sizeof(int [10]));//40 表示所占内存大小，比特位 表示占了40个比特位
	
	short s=0;
	int z=10;	
	printf("%d\n",sizeof(s=z+5));//2
	printf("%d\n",s);//0
	return 0;
}*/
//按位取反 ~ 的练习
/*#include<stdio.h>
int main()
{
	int a=0;//对于0和正数来说，他们的原码，反码，补码都是相同的，都是原码
	//~按（二进制）位取反
	//00000000000000000000000000000000 a的二进制位  二进制序列里面存的是补码
	//11111111111111111111111111111111 (补码)~a 对a的补码按位取反 实际上存储的还是补码
	//11111111111111111111111111111110 (反码)补码-1得到反码
	//10000000000000000000000000000001（原码）补码的符号位不变，其他按位取反 -1
	printf("%d\n",~a); //-1  真正打印出来的是它的原码
	return 0;
}*/
//按位取反的实际应用（将11的二进制位的倒数第三个数字改成1，再将倒数第三个数字改回去）
/*#include<stdio.h>
int main()
{
	int a=11;//00000000000000000000000000001011 11的原码 补码 反码
	a=a|(1<<2);
	printf("%d\n",a);//15
	a=a&(~(1<<2));
	printf("%d\n",a);
	//将11的二进制位的倒数第三个数字改成1
	//00000000000000000000000000001011
	//00000000000000000000000000000100
	//1<<2
	//00000000000000000000000000000001  
	//再将倒数第三个数字改回去
	//00000000000000000000000000001111
	//11111111111111111111111111111011
	//00000000000000000000000000000100
	//00000000000000000000000000001011

	return 0;
}*/
//右移，左移操作符的练习
/*#include<stdio.h>
int main()
{
	int a=5/2;//5/2 商2余1
	int b=5%2;
	float c=5.0/2;//如果想输出来的是小数，就需要被除数或者除数至少有一个数是小数
	double d=5/2.0;
	//double e=5%2.0 这个是错误的，因为取模的操作符两边都需要是整数
	printf("%d\n",a);//2
	printf("%d\n",b);//1
	printf("%f\n",c);//2.500000   
	printf("%f\n",d);//2.500000

}
int mian()
{
	int a=16;
	//不能移动负数，和小数
	//>> 是右移操作符，移动的是二进制位
	//右移操作符有两种方法一种是算术右移，另一种是逻辑右移
	//算术右移是右边丢弃，左边补原符号位；逻辑右移是指右边丢弃，左边补0
	//通常见到的是算术右移；正数的右移有除2的效果 
	//正数的原码，反码，补码都是一样的
	int b=a>>1;
	return 0;
}
int main()
{
	int a=-1;
	//整数的二进制表示有：原码，反码，补码
	//存储到内存中的是补码
	int b=a>>1;
	//10000000000000000000000000000001 这是-1的原码
	//11111111111111111111111111111110 这是反码 符号位不变，其他位按位取反；正数的符号位第一位是0，负数的符号位第一位是1
	//11111111111111111111111111111111 这是补码，反码加1
    //算术右移的话，最右边的补码丢掉一个1，最左边补码补原符号位，还是1，所以内存的补码不变，还是-1
	printf("%d\n",b);//-1
	return 0;
}
int main()
{
	int a=-1;
	int b=a<<1;
	//左移操作符，只需要将左边丢弃，右边补全0，有乘2的效果
	printf("%d",b);
	return 0;
}*/
//&按位与操作符的练习
/*#include<stdio.h>
int main()
{
	int a=3;
	int b=5;
	int c=a&b;
	//3的00000000000000000000000000000011
	//5的00000000000000000000000000000101
	//   00000000000000000000000000000001
	//只要有一个是0就是0，全都是1才是1
	printf("%d",c);//1
}*/
//按位或的操作符练习
/*#include<stdio.h>
int main()
{
		int a=3;
		int b=5;
	//3的00000000000000000000000000000011
	//5的00000000000000000000000000000101
	//   00000000000000000000000000000111
	//只有全为0的时候为0，只要有一个是1则为1
		int c=a|b;
		printf("%d",c);//7
}*/
//按位异或操作符的练习
/*#include<stdio.h>
int main()
{
	int a=5;
	int b=3;
	//3的00000000000000000000000000000011
	//5的00000000000000000000000000000101
	//   00000000000000000000000000000110
	//对应二进制位相同的是0，不同为1
	int c=a^b;
	printf("%d",c);//6
}*/
